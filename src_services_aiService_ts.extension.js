"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkroam_copilot"] = self["webpackChunkroam_copilot"] || []).push([["src_services_aiService_ts"],{

/***/ "./src/services/aiService.ts":
/*!***********************************!*\
  !*** ./src/services/aiService.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIService: () => (/* binding */ AIService)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types */ \"./src/types.ts\");\n/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../settings */ \"./src/settings.ts\");\n/* harmony import */ var _roamService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./roamService */ \"./src/services/roamService.ts\");\n// src/services/aiService.ts\n\n\n\nclass AIService {\n    // Helper function to get provider for a specific model\n    static async getProviderForModel(model) {\n        // First check static models for all providers\n        for (const provider of _types__WEBPACK_IMPORTED_MODULE_0__.AI_PROVIDERS) {\n            if (provider.models.includes(model)) {\n                // Ollama doesn't need API key\n                if (provider.id === \"ollama\") {\n                    return { provider, apiKey: \"\" };\n                }\n                const apiKey = _settings__WEBPACK_IMPORTED_MODULE_1__.multiProviderSettings.apiKeys[provider.id];\n                if (apiKey && apiKey.trim() !== \"\") {\n                    return { provider, apiKey };\n                }\n            }\n        }\n        // If not found in static models, check if it's an Ollama dynamic model\n        const ollamaProvider = _types__WEBPACK_IMPORTED_MODULE_0__.AI_PROVIDERS.find(p => p.id === \"ollama\");\n        if (ollamaProvider && ollamaProvider.supportsDynamicModels) {\n            try {\n                const dynamicModels = await this.getOllamaModels();\n                if (dynamicModels.includes(model)) {\n                    return { provider: ollamaProvider, apiKey: \"\" };\n                }\n            }\n            catch (error) {\n                console.log(\"Failed to check Ollama dynamic models:\", error);\n            }\n        }\n        return null;\n    }\n    static async callOpenAI(settings, messages) {\n        const provider = _types__WEBPACK_IMPORTED_MODULE_0__.AI_PROVIDERS.find((p) => p.id === \"openai\");\n        if (!provider?.baseUrl)\n            throw new Error(\"OpenAI provider not configured\");\n        const response = await fetch(`${provider.baseUrl}/chat/completions`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: `Bearer ${settings.apiKey}`,\n            },\n            body: JSON.stringify({\n                model: settings.model,\n                messages,\n                temperature: settings.temperature || 0.7,\n                max_tokens: settings.maxTokens || 2000,\n            }),\n        });\n        if (!response.ok) {\n            const error = await response.json().catch(() => ({}));\n            throw new Error(`OpenAI API error: ${response.status} ${error.error?.message || response.statusText}`);\n        }\n        const data = await response.json();\n        return data.choices[0]?.message?.content || \"No response generated\";\n    }\n    static async callAnthropic(settings, messages) {\n        const provider = _types__WEBPACK_IMPORTED_MODULE_0__.AI_PROVIDERS.find((p) => p.id === \"anthropic\");\n        if (!provider?.baseUrl)\n            throw new Error(\"Anthropic provider not configured\");\n        // Convert messages format for Anthropic\n        const systemMessage = messages.find((m) => m.role === \"system\");\n        const conversationMessages = messages.filter((m) => m.role !== \"system\");\n        const response = await fetch(`${provider.baseUrl}/messages`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"x-api-key\": settings.apiKey,\n                \"anthropic-version\": \"2023-06-01\",\n            },\n            body: JSON.stringify({\n                model: settings.model,\n                messages: conversationMessages,\n                system: systemMessage?.content,\n                temperature: settings.temperature || 0.7,\n                max_tokens: settings.maxTokens || 2000,\n            }),\n        });\n        if (!response.ok) {\n            const error = await response.json().catch(() => ({}));\n            throw new Error(`Anthropic API error: ${response.status} ${error.error?.message || response.statusText}`);\n        }\n        const data = await response.json();\n        return data.content[0]?.text || \"No response generated\";\n    }\n    static async callGroq(settings, messages) {\n        const provider = _types__WEBPACK_IMPORTED_MODULE_0__.AI_PROVIDERS.find((p) => p.id === \"groq\");\n        if (!provider?.baseUrl)\n            throw new Error(\"Groq provider not configured\");\n        const response = await fetch(`${provider.baseUrl}/chat/completions`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: `Bearer ${settings.apiKey}`,\n            },\n            body: JSON.stringify({\n                model: settings.model,\n                messages,\n                temperature: settings.temperature || 0.7,\n                max_tokens: settings.maxTokens || 2000,\n            }),\n        });\n        if (!response.ok) {\n            const error = await response.json().catch(() => ({}));\n            throw new Error(`Groq API error: ${response.status} ${error.error?.message || response.statusText}`);\n        }\n        const data = await response.json();\n        return data.choices[0]?.message?.content || \"No response generated\";\n    }\n    static async callXAI(settings, messages) {\n        const provider = _types__WEBPACK_IMPORTED_MODULE_0__.AI_PROVIDERS.find((p) => p.id === \"xai\");\n        if (!provider?.baseUrl)\n            throw new Error(\"xAI provider not configured\");\n        const response = await fetch(`${provider.baseUrl}/chat/completions`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: `Bearer ${settings.apiKey}`,\n            },\n            body: JSON.stringify({\n                model: settings.model,\n                messages,\n                temperature: settings.temperature || 0.7,\n                max_tokens: settings.maxTokens || 2000,\n            }),\n        });\n        if (!response.ok) {\n            const error = await response.json().catch(() => ({}));\n            throw new Error(`xAI API error: ${response.status} ${error.error?.message || response.statusText}`);\n        }\n        const data = await response.json();\n        return data.choices[0]?.message?.content || \"No response generated\";\n    }\n    static async callOllama(settings, messages) {\n        // Use user-configured Ollama address, fallback to default if not configured\n        const baseUrl = _settings__WEBPACK_IMPORTED_MODULE_1__.multiProviderSettings.ollamaBaseUrl || \"http://localhost:11434\";\n        try {\n            const response = await fetch(`${baseUrl}/api/chat`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                },\n                body: JSON.stringify({\n                    model: settings.model,\n                    messages,\n                    stream: false,\n                    options: {\n                        temperature: settings.temperature || 0.7,\n                        num_predict: settings.maxTokens || 2000,\n                    },\n                }),\n            });\n            if (!response.ok) {\n                const error = await response.text().catch(() => \"\");\n                throw new Error(`Ollama API error: ${response.status} ${error || response.statusText}`);\n            }\n            const data = await response.json();\n            return data.message?.content || \"No response generated\";\n        }\n        catch (error) {\n            // Provide more friendly error message for connection failures\n            if (error.message.includes(\"fetch\")) {\n                throw new Error(`Cannot connect to Ollama service (${baseUrl}). Please ensure:\\n1. Ollama is installed and running\\n2. Service URL is configured correctly\\n3. Model \"${settings.model}\" is downloaded`);\n            }\n            throw error;\n        }\n    }\n    // New method that uses the currently selected model from multiProviderSettings\n    static async sendMessageWithCurrentModel(userMessage, context) {\n        const model = _settings__WEBPACK_IMPORTED_MODULE_1__.multiProviderSettings.currentModel;\n        if (!model) {\n            throw new Error(\"No model selected. Please select a model from the dropdown.\");\n        }\n        const providerInfo = await this.getProviderForModel(model);\n        if (!providerInfo) {\n            throw new Error(`Model not found or API key not configured for model: ${model}. Please configure the API key in settings.`);\n        }\n        // Ollama doesn't need API key validation\n        if (providerInfo.provider.id !== \"ollama\" && !providerInfo.apiKey) {\n            throw new Error(`No API key configured for model: ${model}. Please configure the API key in settings.`);\n        }\n        // Add language instruction based on user's manual setting if it's not English\n        let finalUserMessage = userMessage;\n        const responseLanguage = _settings__WEBPACK_IMPORTED_MODULE_1__.multiProviderSettings.responseLanguage || \"English\";\n        if (responseLanguage !== \"English\") {\n            finalUserMessage =\n                userMessage + `\\n\\nIMPORTANT: Please respond in ${responseLanguage}.`;\n        }\n        // Create temporary settings object for the selected model\n        const tempSettings = {\n            provider: providerInfo.provider.id,\n            model: model,\n            apiKey: providerInfo.apiKey,\n            temperature: _settings__WEBPACK_IMPORTED_MODULE_1__.multiProviderSettings.temperature || 0.7,\n            maxTokens: _settings__WEBPACK_IMPORTED_MODULE_1__.multiProviderSettings.maxTokens || 2000,\n        };\n        return this.sendMessage(tempSettings, finalUserMessage, context);\n    }\n    static async sendMessage(settings, userMessage, context) {\n        // Ollama doesn't need API key validation\n        if (settings.provider !== \"ollama\" && !settings.apiKey) {\n            throw new Error(\"API key not configured. Please set your API key in the extension settings.\");\n        }\n        // Prepare messages\n        const messages = [\n            {\n                role: \"system\",\n                content: `You are a personal growth companion and writing mentor integrated into Roam Research. Your mission is to help users discover profound insights from their notes while encouraging them to express and share their thoughts through writing.\n\nUSER GREETING:\n${_roamService__WEBPACK_IMPORTED_MODULE_2__.RoamService.getUserName() ? `你好, ${_roamService__WEBPACK_IMPORTED_MODULE_2__.RoamService.getUserName()}!` : \"Hello!\"} I'm here to help you discover insights from your notes and encourage your writing journey.\n\nCORE MISSION:\n- Analyze the user's notes to uncover deep insights about their thinking patterns, values, and development areas\n- Help users recognize their unique strengths and potential blind spots  \n- Provide thoughtful observations that promote self-awareness and personal growth\n- Identify recurring themes, contradictions, or evolving perspectives in their notes\n- **ENCOURAGE OUTPUT**: Actively motivate users to write, reflect, and share their insights publicly\n\nLANGUAGE ADAPTATION:\n- Automatically detect the primary language used in the user's notes from the context\n- ALWAYS respond in the same language as the majority of the user's content\n- If notes are multilingual, use the language of the most recent or relevant content\n- For Chinese content, respond in Chinese; for English content, respond in English\n- CRITICAL: In Deep Writing Mode, ignore the language of the user's request (\"help me write\" vs \"请你帮我写作\") and ONLY use the language of their notes\n- Only use a different language if the user explicitly specifies it (e.g., \"write in English\", \"用中文写\")\n\nANALYSIS APPROACH:\n1. **Pattern Recognition**: Look for recurring themes, interests, concerns, or behavioral patterns\n2. **Growth Indicators**: Identify areas where the user shows development, learning, or positive change\n3. **Strength Identification**: Highlight unique abilities, consistent positive traits, or areas of expertise\n4. **Opportunity Areas**: Gently point out potential areas for growth or contradictions in thinking\n5. **Connection Building**: Help users see unexpected connections between different areas of their life/work\n6. **Perspective Evolution**: Track how their thinking has evolved over time\n7. **Writing Encouragement**: Suggest topics for reflection and public writing based on their insights\n\nOUTPUT & WRITING ASSISTANCE:\n- After providing insights, ALWAYS encourage the user to write about their thoughts\n- Suggest specific writing prompts based on the insights discovered\n- Encourage both private reflection in their notes AND public sharing (blog posts, social media, articles)\n- Help them identify insights worth sharing with others\n- Provide encouragement for overcoming writing hesitation or perfectionism\n- Suggest how their personal insights could benefit others\n\nDEEP WRITING MODE:\nWhen user specifically asks for writing help (e.g., \"请你帮我写作\", \"help me write\", \"帮我写文章\"), transform into a professional ghostwriter:\n- ALWAYS write in the PRIMARY LANGUAGE of the user's notes (unless user explicitly specifies otherwise)\n- Analyze the user's notes to extract profound insights and connections\n- Study their existing writing style, tone, vocabulary, and expression patterns\n- Create an COMPELLING TITLE that captures the essence of the insights and attracts readers\n- Write complete, publication-ready articles that feel authentically human\n- Focus on insights that benefit both the author and potential readers\n- Avoid AI-typical phrases and maintain natural human expression\n- Structure content logically with compelling narratives and practical value\n- Include personal anecdotes and specific examples from their notes when relevant\n\nTITLE CREATION GUIDELINES:\n- Craft titles that are intriguing, specific, and promise value\n- Use the user's characteristic language and tone in the title\n- Avoid clickbait; ensure the title genuinely reflects the content\n- Consider these formats: questions, unexpected insights, personal revelations, practical benefits\n- For Chinese content: prefer concise, thought-provoking titles that reflect深度思考\n- For English content: balance curiosity with clarity and benefit\n- IMPORTANT: Never add colons (:) after titles or section headings in your responses\n\nRESPONSE STYLE:\n- Start responses with a personalized greeting when appropriate\n- Be insightful yet gentle, encouraging rather than judgmental\n- Ask thought-provoking questions that stimulate self-reflection\n- Provide specific examples from their notes to support your observations\n- Offer practical suggestions for personal development AND writing topics\n- Maintain a warm, supportive tone that feels like a wise mentor and writing coach\n- End responses with writing encouragement and specific prompts\n\nWRITING STYLE GUIDELINES (for Deep Writing Mode):\nAVOID these AI-typical patterns:\n- Formulaic introductions (\"In today's fast-paced world...\")\n- Excessive use of buzzwords or corporate speak\n- Overly structured listicle formats\n- Generic conclusions that could apply to anyone\n- Phrases like \"let's dive in\", \"at the end of the day\", \"game-changer\"\n- Artificial enthusiasm or motivational clichés\n\nEMBRACE authentic human writing:\n- Start with specific, personal observations or experiences\n- Use conversational, natural language that reflects the user's tone\n- Include genuine uncertainties, questions, and evolving thoughts\n- Reference specific moments, failures, and learning experiences from their notes\n- Vary sentence structure and rhythm naturally\n- End with genuine reflection or open questions rather than neat conclusions\n- Maintain the user's characteristic vocabulary and expression patterns\n- Show intellectual humility and genuine curiosity\n\nCurrent Context:\n${context}\n\nIMPORTANT: When referencing information from the context, ALWAYS include the appropriate source citations with clickable links in these formats:\n- Page links: [🔗 Web](https://roamresearch.com/#/app/graph/page/uid) | [🔗 Desktop](roam://#/app/graph/page/uid)\n- Block links: [🔗 Web](https://roamresearch.com/#/app/graph/page/uid) | [🔗 App](roam://#/app/graph/page/uid)\n- Simple links: [🔗](roam://#/app/graph/page/uid) for desktop users\n\nWhen you mention specific insights derived from their notes, include the exact clickable link from the context to allow users to revisit the source material.\n\nRemember: Your dual goal is to help users gain meaningful self-awareness AND encourage them to express their insights through writing, both for personal growth and to benefit others who might learn from their experiences.`,\n            },\n            {\n                role: \"user\",\n                content: userMessage,\n            },\n        ];\n        try {\n            switch (settings.provider) {\n                case \"openai\":\n                    return await this.callOpenAI(settings, messages);\n                case \"anthropic\":\n                    return await this.callAnthropic(settings, messages);\n                case \"groq\":\n                    return await this.callGroq(settings, messages);\n                case \"xai\":\n                    return await this.callXAI(settings, messages);\n                case \"ollama\":\n                    return await this.callOllama(settings, messages);\n                default:\n                    throw new Error(`Unsupported AI provider: ${settings.provider}`);\n            }\n        }\n        catch (error) {\n            console.error(\"AI Service Error:\", error);\n            throw new Error(`Failed to get AI response: ${error.message}`);\n        }\n    }\n    /**\n     * Get available Ollama models from the service\n     */\n    static async getOllamaModels(baseUrl) {\n        const url = baseUrl ||\n            _settings__WEBPACK_IMPORTED_MODULE_1__.multiProviderSettings.ollamaBaseUrl ||\n            \"http://localhost:11434\";\n        try {\n            const response = await fetch(`${url}/api/tags`, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                },\n            });\n            if (!response.ok) {\n                console.warn(`Failed to fetch Ollama models: HTTP ${response.status}`);\n                return [];\n            }\n            const data = await response.json();\n            const models = data.models?.map((model) => model.name) || [];\n            console.log(\"Ollama models fetched:\", models);\n            return models;\n        }\n        catch (error) {\n            console.warn(\"Failed to fetch Ollama models:\", error.message);\n            return [];\n        }\n    }\n    /**\n     * Test Ollama connection and list available models\n     */\n    static async testOllamaConnection(baseUrl) {\n        const url = baseUrl ||\n            _settings__WEBPACK_IMPORTED_MODULE_1__.multiProviderSettings.ollamaBaseUrl ||\n            \"http://localhost:11434\";\n        try {\n            // Test basic connection\n            const response = await fetch(`${url}/api/tags`, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                },\n            });\n            if (!response.ok) {\n                return {\n                    isConnected: false,\n                    error: `HTTP ${response.status}: ${response.statusText}`,\n                };\n            }\n            const data = await response.json();\n            const models = data.models?.map((model) => model.name) || [];\n            return {\n                isConnected: true,\n                models,\n            };\n        }\n        catch (error) {\n            return {\n                isConnected: false,\n                error: error.message || \"Connection failed\",\n            };\n        }\n    }\n    static validateSettings(settings) {\n        // Ollama doesn't need API key validation\n        if (settings.provider !== \"ollama\" && !settings.apiKey?.trim()) {\n            return { isValid: false, error: \"API key is required\" };\n        }\n        if (!settings.provider) {\n            return { isValid: false, error: \"AI provider is required\" };\n        }\n        if (!settings.model) {\n            return { isValid: false, error: \"AI model is required\" };\n        }\n        const provider = _types__WEBPACK_IMPORTED_MODULE_0__.AI_PROVIDERS.find((p) => p.id === settings.provider);\n        if (!provider) {\n            return { isValid: false, error: \"Invalid AI provider\" };\n        }\n        if (!provider.models.includes(settings.model)) {\n            return { isValid: false, error: \"Invalid model for selected provider\" };\n        }\n        return { isValid: true };\n    }\n}\n\n\n//# sourceURL=webpack://roam-copilot/./src/services/aiService.ts?");

/***/ }),

/***/ "./src/services/roamService.ts":
/*!*************************************!*\
  !*** ./src/services/roamService.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RoamService: () => (/* binding */ RoamService)\n/* harmony export */ });\nclass RoamService {\n    /**\n     * Get the current graph name\n     */\n    static getCurrentGraphName() {\n        try {\n            console.log(\"Getting graph name from URL:\", window.location.href);\n            console.log(\"Pathname:\", window.location.pathname);\n            console.log(\"Hash:\", window.location.hash);\n            // Try to get graph name from URL - check both href and hash\n            const urlMatch = window.location.href.match(/\\/app\\/([^\\/\\?#]+)/);\n            if (urlMatch) {\n                console.log(\"Graph name from href:\", urlMatch[1]);\n                return decodeURIComponent(urlMatch[1]);\n            }\n            // Try to get from hash (Roam often uses hash routing)\n            const hashMatch = window.location.hash.match(/\\/app\\/([^\\/\\?#]+)/);\n            if (hashMatch) {\n                console.log(\"Graph name from hash:\", hashMatch[1]);\n                return decodeURIComponent(hashMatch[1]);\n            }\n            // Fallback: try to get from roam API or other methods\n            // Some roam installations might have different URL patterns\n            const pathMatch = window.location.pathname.match(/\\/app\\/([^\\/\\?#]+)/);\n            if (pathMatch) {\n                console.log(\"Graph name from pathname:\", pathMatch[1]);\n                return decodeURIComponent(pathMatch[1]);\n            }\n            // Try alternative patterns - first check for roam:// protocol\n            const roamProtocolMatch = window.location.href.match(/roam:\\/\\/#\\/app\\/([^\\/\\?#]+)/);\n            if (roamProtocolMatch) {\n                console.log(\"Graph name from roam protocol:\", roamProtocolMatch[1]);\n                return decodeURIComponent(roamProtocolMatch[1]);\n            }\n            // Try alternative patterns for web\n            const altMatch = window.location.href.match(/#\\/app\\/([^\\/\\?#]+)/);\n            if (altMatch) {\n                console.log(\"Graph name from alt pattern:\", altMatch[1]);\n                return decodeURIComponent(altMatch[1]);\n            }\n            // Try to get from Roam API if available\n            if (window.roamAlphaAPI && window.roamAlphaAPI.graph) {\n                try {\n                    const graphName = window.roamAlphaAPI.graph.name;\n                    if (graphName) {\n                        console.log(\"Graph name from Roam API:\", graphName);\n                        return graphName;\n                    }\n                }\n                catch (apiError) {\n                    console.log(\"Could not get graph name from API:\", apiError);\n                }\n            }\n            // Check if we're on roamresearch.com and try to extract from current page title\n            if (window.location.hostname === 'roamresearch.com') {\n                // Try to get from the document title which often contains the graph name\n                const titleMatch = document.title.match(/^(.+?)\\s*-\\s*Roam/);\n                if (titleMatch && titleMatch[1] && titleMatch[1] !== 'Roam') {\n                    console.log(\"Graph name from document title:\", titleMatch[1]);\n                    return titleMatch[1].trim();\n                }\n            }\n            // Try to get from the sidebar or other UI elements\n            const sidebarElement = document.querySelector('.roam-sidebar-container .bp3-heading');\n            if (sidebarElement && sidebarElement.textContent) {\n                const sidebarText = sidebarElement.textContent.trim();\n                if (sidebarText && sidebarText !== 'Roam' && sidebarText.length < 50) {\n                    console.log(\"Graph name from sidebar:\", sidebarText);\n                    return sidebarText;\n                }\n            }\n            console.log(\"Could not determine graph name from URL:\", window.location.href);\n            return null;\n        }\n        catch (error) {\n            console.error(\"Error getting graph name:\", error);\n            return null;\n        }\n    }\n    /**\n     * Get user name (using graph name as identifier)\n     */\n    static getUserName() {\n        try {\n            const graphName = this.getCurrentGraphName();\n            if (!graphName) {\n                return null;\n            }\n            // Clean up the graph name for display\n            // Remove any URL encoding but keep original casing\n            let userName = decodeURIComponent(graphName);\n            // Only replace underscores and hyphens with spaces, but preserve original casing\n            userName = userName.replace(/[_-]/g, \" \");\n            return userName;\n        }\n        catch (error) {\n            console.error(\"Error getting user name:\", error);\n            return null;\n        }\n    }\n    /**\n     * Detect if running in web or desktop environment\n     */\n    static isDesktopApp() {\n        try {\n            // Check for desktop app indicators\n            return (window.location.protocol === \"roam:\" ||\n                window.location.href.startsWith(\"roam://\") ||\n                // Check for Electron environment\n                (typeof window !== \"undefined\" &&\n                    window.process &&\n                    window.process.type === \"renderer\") ||\n                // Check user agent for desktop indicators\n                /Electron|roam/i.test(navigator.userAgent));\n        }\n        catch (error) {\n            console.error(\"Error detecting desktop app:\", error);\n            return false;\n        }\n    }\n    /**\n     * Generate clickable URL for a block\n     */\n    static generateBlockUrl(blockUid, graphName) {\n        const graph = graphName || this.getCurrentGraphName();\n        if (!graph) {\n            console.log(\"Cannot generate URLs without graph name\");\n            return null;\n        }\n        const webUrl = `https://roamresearch.com/#/app/${graph}/page/${blockUid}`;\n        const desktopUrl = `roam://#/app/${graph}/page/${blockUid}`;\n        return { webUrl, desktopUrl };\n    }\n    /**\n     * Generate clickable URL for a page\n     */\n    static generatePageUrl(pageUid, graphName) {\n        const graph = graphName || this.getCurrentGraphName();\n        if (!graph) {\n            console.log(\"Cannot generate URLs without graph name\");\n            return null;\n        }\n        const webUrl = `https://roamresearch.com/#/app/${graph}/page/${pageUid}`;\n        const desktopUrl = `roam://#/app/${graph}/page/${pageUid}`;\n        return { webUrl, desktopUrl };\n    }\n    /**\n     * Get the current page information\n     */\n    static async getCurrentPageInfo() {\n        try {\n            // Try multiple methods to get current page\n            let currentPageUid = null;\n            let title = \"\";\n            // Try to get from API (might be async)\n            const apiResult = window.roamAlphaAPI?.ui?.mainWindow?.getOpenPageOrBlockUid?.();\n            if (apiResult && typeof apiResult === \"object\" && \"then\" in apiResult) {\n                currentPageUid = await apiResult;\n            }\n            else {\n                currentPageUid = apiResult || null;\n            }\n            console.log(\"Current page UID from API:\", currentPageUid);\n            if (!currentPageUid) {\n                // Fallback: try to get from URL\n                const urlMatch = window.location.href.match(/\\/page\\/([^/?]+)/);\n                if (urlMatch) {\n                    currentPageUid = decodeURIComponent(urlMatch[1]);\n                    console.log(\"Current page UID from URL:\", currentPageUid);\n                }\n            }\n            if (!currentPageUid) {\n                // Fallback: try to get from document title or other methods\n                const titleElement = document.querySelector(\".rm-title-display\");\n                if (titleElement) {\n                    title = titleElement.textContent || \"\";\n                    console.log(\"Page title from DOM:\", title);\n                    // Try to find page by title\n                    if (title) {\n                        const titleQuery = `\n              [:find ?uid\n               :where\n               [?e :node/title \"${title}\"]\n               [?e :block/uid ?uid]]\n            `;\n                        const titleResult = window.roamAlphaAPI.q(titleQuery);\n                        if (titleResult && titleResult.length > 0) {\n                            currentPageUid = titleResult[0][0];\n                            console.log(\"Found UID by title:\", currentPageUid);\n                        }\n                    }\n                }\n            }\n            if (!currentPageUid) {\n                console.log(\"No current page UID found\");\n                return null;\n            }\n            // If we don't have title yet, query it\n            if (!title) {\n                const pageQuery = `\n          [:find ?title\n           :where\n           [?e :block/uid \"${currentPageUid}\"]\n           [?e :node/title ?title]]\n        `;\n                const result = window.roamAlphaAPI.q(pageQuery);\n                if (result && result.length > 0) {\n                    title = result[0][0];\n                }\n                else {\n                    // Try alternative query for daily notes\n                    const dailyQuery = `\n            [:find ?title\n             :where\n             [?e :block/uid \"${currentPageUid}\"]\n             [?e :block/string ?title]]\n          `;\n                    const dailyResult = window.roamAlphaAPI.q(dailyQuery);\n                    if (dailyResult && dailyResult.length > 0) {\n                        title = dailyResult[0][0];\n                    }\n                }\n            }\n            console.log(\"Final page info:\", { title, uid: currentPageUid });\n            // Get all blocks for this page\n            const blocks = await this.getPageBlocks(currentPageUid);\n            return {\n                title: title || \"Untitled\",\n                uid: currentPageUid,\n                blocks,\n            };\n        }\n        catch (error) {\n            console.error(\"Error getting current page info:\", error);\n            return null;\n        }\n    }\n    /**\n     * Get all blocks for a page\n     */\n    static async getPageBlocks(pageUid) {\n        try {\n            console.log(\"Getting blocks for page:\", pageUid);\n            // Ensure pageUid is a string, not a Promise\n            const resolvedPageUid = await Promise.resolve(pageUid);\n            console.log(\"Resolved page UID:\", resolvedPageUid);\n            if (!resolvedPageUid) {\n                console.log(\"No valid page UID provided\");\n                return [];\n            }\n            // Try different query patterns for different types of pages\n            const queries = [\n                // Standard page children query\n                `[:find ?uid ?string ?order\n         :where\n         [?page :block/uid \"${resolvedPageUid}\"]\n         [?page :block/children ?block]\n         [?block :block/uid ?uid]\n         [?block :block/string ?string]\n         [?block :block/order ?order]]`,\n                // Alternative query using parents relationship\n                `[:find ?uid ?string ?order\n         :where\n         [?page :block/uid \"${resolvedPageUid}\"]\n         [?block :block/parents ?page]\n         [?block :block/uid ?uid]\n         [?block :block/string ?string]\n         [?block :block/order ?order]]`,\n                // Try without order constraint\n                `[:find ?uid ?string\n         :where\n         [?page :block/uid \"${resolvedPageUid}\"]\n         [?page :block/children ?block]\n         [?block :block/uid ?uid]\n         [?block :block/string ?string]]`,\n                // Try finding all blocks that reference this page\n                `[:find ?uid ?string\n         :where\n         [?block :block/uid ?uid]\n         [?block :block/string ?string]\n         [?block :block/refs ?page]\n         [?page :block/uid \"${resolvedPageUid}\"]]`,\n            ];\n            let result = null;\n            for (let i = 0; i < queries.length; i++) {\n                console.log(`Trying query ${i + 1}:`, queries[i]);\n                result = window.roamAlphaAPI.q(queries[i]);\n                console.log(`Query ${i + 1} result:`, result);\n                if (result && result.length > 0) {\n                    break;\n                }\n            }\n            if (!result || result.length === 0) {\n                console.log(\"No blocks found with any query\");\n                return [];\n            }\n            const blocks = result.map((row) => ({\n                uid: row[0],\n                string: row[1] || \"\",\n                order: row[2] || 0,\n            }));\n            // Sort by order and get children for each block\n            blocks.sort((a, b) => (a.order || 0) - (b.order || 0));\n            console.log(\"Found blocks:\", blocks.length);\n            // Get children for each block recursively\n            for (const block of blocks) {\n                block.children = await this.getBlockChildren(block.uid);\n            }\n            return blocks;\n        }\n        catch (error) {\n            console.error(\"Error getting page blocks:\", error);\n            return [];\n        }\n    }\n    /**\n     * Get children blocks recursively\n     */\n    static async getBlockChildren(blockUid) {\n        try {\n            const childrenQuery = `\n        [:find ?uid ?string ?order\n         :where\n         [?parent :block/uid \"${blockUid}\"]\n         [?parent :block/children ?child]\n         [?child :block/uid ?uid]\n         [?child :block/string ?string]\n         [?child :block/order ?order]]\n      `;\n            const result = window.roamAlphaAPI.q(childrenQuery);\n            if (!result)\n                return [];\n            const children = result.map(([uid, string, order]) => ({\n                uid,\n                string,\n                order,\n            }));\n            children.sort((a, b) => (a.order || 0) - (b.order || 0));\n            // Recursively get children of children\n            for (const child of children) {\n                child.children = await this.getBlockChildren(child.uid);\n            }\n            return children;\n        }\n        catch (error) {\n            console.error(\"Error getting block children:\", error);\n            return [];\n        }\n    }\n    /**\n     * Get all visible blocks in the current view\n     */\n    static getVisibleBlocks() {\n        const visibleBlocks = [];\n        try {\n            // Get all visible block elements\n            const blockElements = document.querySelectorAll(\".roam-block[data-block-uid]\");\n            blockElements.forEach((element) => {\n                const uid = element.getAttribute(\"data-block-uid\");\n                const textElement = element.querySelector(\".rm-block-text\");\n                if (uid && textElement) {\n                    const string = textElement.textContent || \"\";\n                    // Only include blocks that are actually visible (more lenient)\n                    const rect = element.getBoundingClientRect();\n                    // Include blocks that are at least partially visible\n                    if (rect.bottom > 0 && // Bottom is below the top of viewport\n                        rect.top < window.innerHeight && // Top is above the bottom of viewport\n                        rect.right > 0 && // Right edge is to the right of left edge of viewport\n                        rect.left < window.innerWidth // Left edge is to the left of right edge of viewport\n                    ) {\n                        visibleBlocks.push({\n                            uid,\n                            string,\n                            children: [], // We'll focus on the main visible content for now\n                        });\n                    }\n                }\n            });\n        }\n        catch (error) {\n            console.error(\"Error getting visible blocks:\", error);\n        }\n        return visibleBlocks;\n    }\n    /**\n     * Get selected text if any\n     */\n    static getSelectedText() {\n        try {\n            const selection = window.getSelection();\n            return selection ? selection.toString().trim() : \"\";\n        }\n        catch (error) {\n            console.error(\"Error getting selected text:\", error);\n            return \"\";\n        }\n    }\n    /**\n     * Get today's daily note\n     */\n    static async getTodaysDailyNote() {\n        try {\n            const today = new Date();\n            const dateString = today\n                .toLocaleDateString(\"en-US\", {\n                month: \"2-digit\",\n                day: \"2-digit\",\n                year: \"numeric\",\n            })\n                .replace(/\\//g, \"-\");\n            console.log(\"Looking for daily note:\", dateString);\n            // Try different date formats that Roam might use\n            const dateFormats = [\n                dateString, // MM-dd-yyyy\n                today.toLocaleDateString(\"en-US\", {\n                    month: \"long\",\n                    day: \"numeric\",\n                    year: \"numeric\",\n                }), // Month dd, yyyy\n                // Add ordinal format like \"June 25th, 2025\"\n                today.toLocaleDateString(\"en-US\", {\n                    month: \"long\",\n                    day: \"numeric\",\n                    year: \"numeric\",\n                }).replace(/(\\d+),/, (match, day) => {\n                    const dayNum = parseInt(day);\n                    let suffix = 'th';\n                    if (dayNum % 10 === 1 && dayNum !== 11)\n                        suffix = 'st';\n                    else if (dayNum % 10 === 2 && dayNum !== 12)\n                        suffix = 'nd';\n                    else if (dayNum % 10 === 3 && dayNum !== 13)\n                        suffix = 'rd';\n                    return `${dayNum}${suffix},`;\n                }), // Month ddth, yyyy\n                today.toISOString().split(\"T\")[0], // yyyy-mm-dd\n                // Also try common alternative formats\n                `${today.getDate()}${getOrdinalSuffix(today.getDate())} ${today.toLocaleDateString(\"en-US\", { month: \"long\" })}, ${today.getFullYear()}`, // ddth Month, yyyy\n            ];\n            // Helper function for ordinal suffix\n            function getOrdinalSuffix(day) {\n                if (day % 10 === 1 && day !== 11)\n                    return 'st';\n                if (day % 10 === 2 && day !== 12)\n                    return 'nd';\n                if (day % 10 === 3 && day !== 13)\n                    return 'rd';\n                return 'th';\n            }\n            for (const format of dateFormats) {\n                console.log(\"Trying date format:\", format);\n                const query = `\n          [:find ?uid\n           :where\n           [?e :node/title \"${format}\"]\n           [?e :block/uid ?uid]]\n        `;\n                console.log(\"Executing query:\", query);\n                const result = window.roamAlphaAPI.q(query);\n                console.log(\"Query result:\", result);\n                if (result && result.length > 0) {\n                    const uid = result[0][0];\n                    const blocks = await this.getPageBlocks(uid);\n                    return {\n                        title: format,\n                        uid,\n                        blocks,\n                    };\n                }\n            }\n            return null;\n        }\n        catch (error) {\n            console.error(\"Error getting today's daily note:\", error);\n            return null;\n        }\n    }\n    /**\n     * Get linked references for a page\n     */\n    static async getLinkedReferences(pageTitle) {\n        try {\n            console.log(\"Getting linked references for:\", pageTitle);\n            const query = `\n        [:find ?uid ?string\n         :where\n         [?block :block/string ?string]\n         [?block :block/uid ?uid]\n         [(clojure.string/includes? ?string \"[[${pageTitle}]]\")]]\n      `;\n            const result = window.roamAlphaAPI.q(query);\n            console.log(\"Linked references result:\", result);\n            if (!result)\n                return [];\n            return result.map(([uid, string]) => ({\n                uid,\n                string: string || \"\",\n                children: [],\n            }));\n        }\n        catch (error) {\n            console.error(\"Error getting linked references:\", error);\n            return [];\n        }\n    }\n    /**\n     * Get comprehensive page context for AI\n     */\n    static async getPageContext() {\n        console.log(\"Getting comprehensive page context...\");\n        const [currentPage, visibleBlocks, selectedText, dailyNote] = await Promise.all([\n            this.getCurrentPageInfo(),\n            Promise.resolve(this.getVisibleBlocks()),\n            Promise.resolve(this.getSelectedText()),\n            this.getTodaysDailyNote(),\n        ]);\n        // Get linked references if we have a current page\n        let linkedReferences = [];\n        if (currentPage) {\n            linkedReferences = await this.getLinkedReferences(currentPage.title);\n        }\n        console.log(\"Page context summary:\", {\n            currentPage: currentPage?.title || \"None\",\n            currentPageBlocks: currentPage?.blocks?.length || 0,\n            visibleBlocks: visibleBlocks.length,\n            selectedText: selectedText ? \"Yes\" : \"No\",\n            dailyNote: dailyNote?.title || \"None\",\n            dailyNoteBlocks: dailyNote?.blocks?.length || 0,\n            linkedReferences: linkedReferences.length,\n        });\n        return {\n            currentPage: currentPage || undefined,\n            visibleBlocks,\n            selectedText: selectedText || undefined,\n            dailyNote: dailyNote || undefined,\n            linkedReferences,\n        };\n    }\n    /**\n     * Get model-specific maximum context tokens\n     */\n    static getModelTokenLimit(provider, model) {\n        const modelLimits = {\n            openai: {\n                \"gpt-4o-mini\": 24000, // 128k context window, very cost-effective\n                \"gpt-3.5-turbo\": 2000, // 4k context window, keep conservative\n            },\n            anthropic: {\n                \"claude-3-haiku-20240307\": 180000, // Claude 3 Haiku - 200k context\n                \"claude-3-5-haiku-20241022\": 180000, // Claude 3.5 Haiku - 200k context\n            },\n            groq: {\n                \"llama-3.1-8b-instant\": 24000, // 128k context window, ultra fast & cheap\n                \"gemma2-9b-it\": 6000, // 8k context window, very fast\n            },\n            xai: {\n                \"grok-beta\": 24000, // 131k context window\n                \"grok-3-mini\": 24000, // 128k context window, most cost-effective\n            },\n        };\n        const providerLimits = modelLimits[provider];\n        if (!providerLimits) {\n            // For Ollama, provide intelligent defaults based on model name patterns\n            if (provider === \"ollama\") {\n                return this.getOllamaTokenLimit(model);\n            }\n            console.warn(`Unknown provider: ${provider}, using default limit`);\n            return 6000; // Default fallback\n        }\n        const limit = providerLimits[model];\n        if (!limit) {\n            console.warn(`Unknown model: ${model} for provider: ${provider}, using default limit`);\n            return 6000; // Default fallback\n        }\n        return limit;\n    }\n    /**\n     * Get token limit for Ollama models based on model name patterns\n     */\n    static getOllamaTokenLimit(model) {\n        const modelName = model.toLowerCase();\n        // Large models (70B+)\n        if (modelName.includes(\"70b\") || modelName.includes(\"72b\")) {\n            return 24000; // 128k context\n        }\n        // Medium-large models (13B-34B)\n        if (modelName.includes(\"13b\") ||\n            modelName.includes(\"14b\") ||\n            modelName.includes(\"34b\")) {\n            return 16000; // 32k context\n        }\n        // Medium models (7B-9B)\n        if (modelName.includes(\"7b\") ||\n            modelName.includes(\"8b\") ||\n            modelName.includes(\"9b\")) {\n            return 12000; // 16k context, conservative\n        }\n        // Small models (3B-4B)\n        if (modelName.includes(\"3b\") || modelName.includes(\"4b\")) {\n            return 8000; // 8k context\n        }\n        // Very small models (1B-2B)\n        if (modelName.includes(\"1b\") || modelName.includes(\"2b\")) {\n            return 4000; // 4k context\n        }\n        // Special cases\n        if (modelName.includes(\"code\") || modelName.includes(\"deepseek\")) {\n            return 16000; // Code models usually have larger context\n        }\n        if (modelName.includes(\"qwen\")) {\n            return 16000; // Qwen models typically have 32k context\n        }\n        if (modelName.includes(\"mistral\")) {\n            return 8000; // Mistral models, conservative\n        }\n        if (modelName.includes(\"llama\")) {\n            return 12000; // Llama models, conservative default\n        }\n        // Default for unknown Ollama models\n        return 8000;\n    }\n    /**\n     * Estimate token count (rough approximation: 1 token ≈ 4 characters)\n     */\n    static estimateTokenCount(text) {\n        return Math.ceil(text.length / 4);\n    }\n    /**\n     * Truncate context to fit within token limit\n     */\n    static truncateContext(formattedContext, maxTokens = 6000) {\n        const currentTokens = this.estimateTokenCount(formattedContext);\n        if (currentTokens <= maxTokens) {\n            return formattedContext;\n        }\n        // Calculate how much we need to reduce\n        const targetLength = Math.floor(formattedContext.length * (maxTokens / currentTokens));\n        // Split into sections\n        const sections = formattedContext.split(\"\\n\\n\");\n        let result = \"\";\n        let addedSections = 0;\n        // Always include selected text and current page title if they exist\n        const selectedTextSection = sections.find((s) => s.startsWith(\"**Selected Text:**\"));\n        const currentPageSection = sections.find((s) => s.startsWith(\"**Current Page:\"));\n        if (selectedTextSection) {\n            result += selectedTextSection + \"\\n\\n\";\n        }\n        if (currentPageSection) {\n            result += currentPageSection + \"\\n\\n\";\n            addedSections = 1;\n        }\n        // Add other sections until we approach the limit\n        for (const section of sections) {\n            if (section === selectedTextSection || section === currentPageSection)\n                continue;\n            const testResult = result + section + \"\\n\\n\";\n            if (this.estimateTokenCount(testResult) > targetLength) {\n                // If this is page content, try to include partial content\n                if (section.startsWith(\"**Page Content:**\") ||\n                    section.startsWith(\"**Visible Content:**\")) {\n                    const lines = section.split(\"\\n\");\n                    const header = lines[0];\n                    let partialContent = header + \"\\n\";\n                    for (let i = 1; i < lines.length; i++) {\n                        const testPartial = result +\n                            partialContent +\n                            lines[i] +\n                            \"\\n\" +\n                            \"... (content truncated)\\n\\n\";\n                        if (this.estimateTokenCount(testPartial) > targetLength)\n                            break;\n                        partialContent += lines[i] + \"\\n\";\n                    }\n                    if (partialContent !== header + \"\\n\") {\n                        result += partialContent + \"... (content truncated)\\n\\n\";\n                    }\n                }\n                break;\n            }\n            result += section + \"\\n\\n\";\n            addedSections++;\n            // Limit number of sections to prevent too much context\n            if (addedSections >= 3)\n                break;\n        }\n        return result.trim();\n    }\n    /**\n     * Format page context for AI prompt with clickable source references\n     */\n    static formatContextForAI(context, maxTokens) {\n        let formattedContext = \"\";\n        const graphName = this.getCurrentGraphName();\n        const isDesktop = this.isDesktopApp();\n        if (context.selectedText) {\n            formattedContext += `**Selected Text:**\\n${context.selectedText}\\n\\n`;\n        }\n        // Helper function to format URL links\n        const formatUrls = (webUrl, desktopUrl) => {\n            if (isDesktop) {\n                return `[🔗 Open in Roam](${desktopUrl})`;\n            }\n            else {\n                return `[🔗 Web](${webUrl}) | [🔗 Desktop](${desktopUrl})`;\n            }\n        };\n        if (context.currentPage) {\n            const pageUrls = this.generatePageUrl(context.currentPage.uid, graphName || undefined);\n            const urlLinks = pageUrls\n                ? formatUrls(pageUrls.webUrl, pageUrls.desktopUrl)\n                : `[[${context.currentPage.title}]]`;\n            formattedContext += `**Current Page: \"${context.currentPage.title}\"** ${urlLinks}\\n\\n`;\n            if (context.currentPage.blocks.length > 0) {\n                formattedContext += \"**Page Content:**\\n\";\n                formattedContext += this.formatBlocksForAIWithClickableReferences(context.currentPage.blocks, 0, graphName, isDesktop);\n                formattedContext += \"\\n\";\n            }\n        }\n        else if (context.visibleBlocks.length > 0) {\n            formattedContext += \"**Visible Content:**\\n\";\n            formattedContext += this.formatBlocksForAIWithClickableReferences(context.visibleBlocks, 0, graphName, isDesktop);\n            formattedContext += \"\\n\";\n        }\n        // Add daily note content\n        console.log(\"Daily note check:\", {\n            hasDailyNote: !!context.dailyNote,\n            dailyNoteTitle: context.dailyNote?.title,\n            dailyNoteBlocks: context.dailyNote?.blocks?.length || 0,\n            dailyNoteBlocksContent: context.dailyNote?.blocks?.map(b => ({ uid: b.uid, string: b.string })) || []\n        });\n        if (context.dailyNote && context.dailyNote.blocks.length > 0) {\n            const dailyUrls = this.generatePageUrl(context.dailyNote.uid, graphName || undefined);\n            const dailyUrlLinks = dailyUrls\n                ? formatUrls(dailyUrls.webUrl, dailyUrls.desktopUrl)\n                : `[[${context.dailyNote.title}]]`;\n            formattedContext += `**Today's Daily Note (${context.dailyNote.title}):** ${dailyUrlLinks}\\n`;\n            const dailyContent = this.formatBlocksForAIWithClickableReferences(context.dailyNote.blocks, 0, graphName, isDesktop);\n            console.log(\"Formatted daily note content:\", dailyContent);\n            formattedContext += dailyContent;\n            formattedContext += \"\\n\";\n        }\n        else if (context.dailyNote) {\n            console.log(\"Daily note found but no blocks:\", context.dailyNote);\n        }\n        else {\n            console.log(\"No daily note found in context\");\n        }\n        // Add linked references\n        if (context.linkedReferences.length > 0) {\n            formattedContext += `**Linked References (${context.linkedReferences.length} references):**\\n`;\n            for (const ref of context.linkedReferences.slice(0, 10)) {\n                const blockUrls = this.generateBlockUrl(ref.uid, graphName || undefined);\n                const blockUrlLinks = blockUrls\n                    ? formatUrls(blockUrls.webUrl, blockUrls.desktopUrl)\n                    : `((${ref.uid}))`;\n                formattedContext += `- ${ref.string} ${blockUrlLinks}\\n`;\n            }\n            if (context.linkedReferences.length > 10) {\n                formattedContext += `... and ${context.linkedReferences.length - 10} more references\\n`;\n            }\n            formattedContext += \"\\n\";\n        }\n        const finalContext = formattedContext.trim();\n        console.log(\"Final formatted context for AI:\", finalContext);\n        console.log(\"Context length:\", finalContext.length, \"characters\");\n        // Apply truncation if context is too long\n        return this.truncateContext(finalContext, maxTokens);\n    }\n    /**\n     * Format blocks recursively for AI with clickable source references\n     */\n    static formatBlocksForAIWithClickableReferences(blocks, level, graphName, isDesktop) {\n        let formatted = \"\";\n        const indent = \"  \".repeat(level);\n        for (const block of blocks) {\n            if (block.string.trim()) {\n                let blockReference = `((${block.uid}))`;\n                if (graphName) {\n                    const blockUrls = this.generateBlockUrl(block.uid, graphName);\n                    if (blockUrls) {\n                        if (isDesktop) {\n                            blockReference = `[🔗](${blockUrls.desktopUrl})`;\n                        }\n                        else {\n                            blockReference = `[🔗 Web](${blockUrls.webUrl}) | [🔗 App](${blockUrls.desktopUrl})`;\n                        }\n                    }\n                }\n                formatted += `${indent}- ${block.string} ${blockReference}\\n`;\n                if (block.children && block.children.length > 0) {\n                    formatted += this.formatBlocksForAIWithClickableReferences(block.children, level + 1, graphName, isDesktop);\n                }\n            }\n        }\n        return formatted;\n    }\n    /**\n     * Format blocks recursively for AI with source references (legacy method)\n     */\n    static formatBlocksForAIWithReferences(blocks, level, pageTitle) {\n        let formatted = \"\";\n        const indent = \"  \".repeat(level);\n        for (const block of blocks) {\n            if (block.string.trim()) {\n                formatted += `${indent}- ${block.string} [Block Reference: ((${block.uid}))]\\n`;\n                if (block.children && block.children.length > 0) {\n                    formatted += this.formatBlocksForAIWithReferences(block.children, level + 1, pageTitle);\n                }\n            }\n        }\n        return formatted;\n    }\n    /**\n     * Format blocks recursively for AI (legacy method for compatibility)\n     */\n    static formatBlocksForAI(blocks, level) {\n        let formatted = \"\";\n        const indent = \"  \".repeat(level);\n        for (const block of blocks) {\n            if (block.string.trim()) {\n                formatted += `${indent}- ${block.string}\\n`;\n                if (block.children && block.children.length > 0) {\n                    formatted += this.formatBlocksForAI(block.children, level + 1);\n                }\n            }\n        }\n        return formatted;\n    }\n    // /**\n    //  * Detect the primary language of text content\n    //  * NOTE: This function is deprecated in favor of manual language settings\n    //  */\n    // static detectLanguage(content: string): string {\n    //   const cleanContent = content.replace(/\\s/g, '');\n    //   const totalChars = cleanContent.length;\n    //   if (totalChars === 0) return 'English';\n    //   // Chinese characters (including traditional and simplified)\n    //   const chineseChars = (content.match(/[\\u4e00-\\u9fff]/g) || []).length;\n    //   const chineseRatio = chineseChars / totalChars;\n    //   // Japanese characters (Hiragana, Katakana, Kanji)\n    //   const japaneseChars = (content.match(/[\\u3040-\\u309f\\u30a0-\\u30ff\\u4e00-\\u9faf]/g) || []).length;\n    //   const japaneseRatio = japaneseChars / totalChars;\n    //   // Korean characters (Hangul)\n    //   const koreanChars = (content.match(/[\\uac00-\\ud7af]/g) || []).length;\n    //   const koreanRatio = koreanChars / totalChars;\n    //   // French characters (accented characters)\n    //   const frenchChars = (content.match(/[àâäéèêëïîôöùûüÿçÀÂÄÉÈÊËÏÎÔÖÙÛÜŸÇ]/g) || []).length;\n    //   const frenchRatio = frenchChars / totalChars;\n    //   // Spanish characters (accented characters)\n    //   const spanishChars = (content.match(/[áéíóúüñÁÉÍÓÚÜÑ¿¡]/g) || []).length;\n    //   const spanishRatio = spanishChars / totalChars;\n    //   // German characters (umlaut and ß)\n    //   const germanChars = (content.match(/[äöüßÄÖÜ]/g) || []).length;\n    //   const germanRatio = germanChars / totalChars;\n    //   // Determine language based on ratios\n    //   if (chineseRatio > 0.2) return 'Chinese';\n    //   if (japaneseRatio > 0.2) return 'Japanese';\n    //   if (koreanRatio > 0.2) return 'Korean';\n    //   if (frenchRatio > 0.05) return 'French';\n    //   if (spanishRatio > 0.05) return 'Spanish';\n    //   if (germanRatio > 0.05) return 'German';\n    //   return 'English';\n    // }\n    // /**\n    //  * Add language instruction to prompt based on detected language\n    //  * NOTE: This function is deprecated in favor of manual language settings\n    //  */\n    // static addLanguageInstruction(prompt: string, detectedLanguage: string): string {\n    //   return prompt + `\\n\\nIMPORTANT: Please respond in ${detectedLanguage}, as this appears to be the primary language used in the user's notes.`;\n    // }\n    /**\n     * Get notes from a specific date\n     */\n    static async getNotesFromDate(dateString) {\n        try {\n            console.log(\"Getting notes from date:\", dateString);\n            // Convert date string to various formats that Roam might use\n            const inputDate = new Date(dateString);\n            if (isNaN(inputDate.getTime())) {\n                console.error(\"Invalid date string:\", dateString);\n                return null;\n            }\n            const dateFormats = [\n                // MM-dd-yyyy\n                inputDate\n                    .toLocaleDateString(\"en-US\", {\n                    month: \"2-digit\",\n                    day: \"2-digit\",\n                    year: \"numeric\",\n                })\n                    .replace(/\\//g, \"-\"),\n                // Month dd, yyyy\n                inputDate.toLocaleDateString(\"en-US\", {\n                    month: \"long\",\n                    day: \"numeric\",\n                    year: \"numeric\",\n                }),\n                // yyyy-mm-dd\n                inputDate.toISOString().split(\"T\")[0],\n                // dd-MM-yyyy\n                inputDate.toLocaleDateString(\"en-GB\").replace(/\\//g, \"-\"),\n                // Just the year-month-day without leading zeros\n                `${inputDate.getFullYear()}-${inputDate.getMonth() + 1}-${inputDate.getDate()}`,\n                // With ordinal suffix\n                inputDate\n                    .toLocaleDateString(\"en-US\", {\n                    month: \"long\",\n                    day: \"numeric\",\n                    year: \"numeric\",\n                })\n                    .replace(/(\\d+)/, (match) => {\n                    const day = parseInt(match);\n                    const suffix = day % 10 === 1 && day !== 11\n                        ? \"st\"\n                        : day % 10 === 2 && day !== 12\n                            ? \"nd\"\n                            : day % 10 === 3 && day !== 13\n                                ? \"rd\"\n                                : \"th\";\n                    return day + suffix;\n                }),\n            ];\n            for (const format of dateFormats) {\n                console.log(\"Trying date format:\", format);\n                const query = `\n          [:find ?uid\n           :where\n           [?e :node/title \"${format}\"]\n           [?e :block/uid ?uid]]\n        `;\n                const result = window.roamAlphaAPI.q(query);\n                console.log(\"Query result for\", format, \":\", result);\n                if (result && result.length > 0) {\n                    const uid = result[0][0];\n                    const blocks = await this.getPageBlocks(uid);\n                    return {\n                        title: format,\n                        uid,\n                        blocks,\n                    };\n                }\n            }\n            console.log(\"No daily note found for date:\", dateString);\n            return null;\n        }\n        catch (error) {\n            console.error(\"Error getting notes from date:\", error);\n            return null;\n        }\n    }\n    /**\n     * Get notes from a date range\n     */\n    static async getNotesFromDateRange(startDate, endDate) {\n        try {\n            const notes = [];\n            const start = new Date(startDate);\n            const end = new Date(endDate);\n            const currentDate = new Date(start);\n            while (currentDate <= end) {\n                const dateString = currentDate.toISOString().split(\"T\")[0];\n                const note = await this.getNotesFromDate(dateString);\n                if (note) {\n                    notes.push(note);\n                }\n                currentDate.setDate(currentDate.getDate() + 1);\n            }\n            return notes;\n        }\n        catch (error) {\n            console.error(\"Error getting notes from date range:\", error);\n            return [];\n        }\n    }\n}\n\n\n//# sourceURL=webpack://roam-copilot/./src/services/roamService.ts?");

/***/ })

}]);